#labels Phase-Implementation,HOWTO
= Creating a jacp Project =

A jacp Application consists of one workbench and at least one perspective containing an ui component. The platform uses spring IoC to define and handle all declared beans (workbench, perspective, component). Create a spring context xml file (resources.xml) and put it into "org.jacp.impl.resource" package folder.

= Creating a workbench =
A workbench defines the basic application layout. The defined layout is the structure for all containing perspectives an components. At the moment there are three different base structures, a tabbed mode, a window mode and a modal mode. 

* The tabbed mode defines that every perspective is opend in a single tab of your application.
* The window mode create for each perspective a new frame in our application
* At the modal mode only one perspective is visible at once. Here you can use perspective like stacks where the top perspective is visible 

Although the workbench isn't a typical component like perspective or subcomponent its behavior is the same. A workbench can add menu entries (if you declare a menu structure) and can be notified by any component to change the structure of defined layout. That means that you can change the complete look of your application (defined in a workbench) at runntime of your application without need to restart it.    

== create the workbench bean ==

== declare the bean at spring context ==

= Creating a perspective =

= Creating components =


= Component handling best practice =

Assume you create two editors, a message producer and a message consumer. The producer component contain a button to start a message transaction to the consumer (a while loop).  Note: all components are running in threads only when the handle method is executed. After execution all components stay in EventDispatchThread. 
So what did this mean? 
For component B (the consumer) this means that it will run in an own thread as long messages are arriving. Component A (the producer) either running on eventDispatchThread (the bad way) or it has to trigger his own handle method (the good way).

Variant A shows the *"bad"* way of handling. *Try to avoid this*, when running long tasks.

{{{
public class DemoMessagePerformanceEditorProducer extends ASwingEditor {
	
	private JPanel panel = new JPanel();
	final JButton button = new JButton("send 1000 messages");

	@Override
	public void addMenuEntries(final Container meuneBar) {
	}

	@Override
	public void handleBarEntries(final Container toolBar,
			final Container bottomBar) {
	}

	@Override
	public Container handle(final IAction<ActionEvent, Object> action) {
	
		
		button.addActionListener(new ActionListener() {

			@Override
			public void actionPerformed(final ActionEvent e) {
				int p = 0;
				while (p < 1000) {
					final IActionListener<ActionListener, ActionEvent, Object> listener = getActionListener();
					listener.getAction().setMessage("id09", "message");
					listener.getListener().actionPerformed(e);
					p++;

				}
			}
		});
		
		panel.add(button);
		return panel;
	}
}}} 


And now the *"good"* way of handling this message. In the following example the button sends a message to itself and then starting his message loop, so the complete loop time will be executed in a thread.

{{{


public class DemoMessagePerformanceEditorProducer extends ASwingEditor {
	
	private JPanel anel = new JPanel();
	final JButton button = new JButton("send 1000 messages");

	@Override
	public void addMenuEntries(final Container meuneBar) {

	}

	@Override
	public void handleBarEntries(final Container toolBar,
			final Container bottomBar) {
	}

	@Override
	public Container handle(final IAction<ActionEvent, Object> action) {

               if(action.getMessage().equals("begin")) {
			int p = 0;
			while (p < 99) {
				final IActionListener<ActionListener, ActionEvent, Object> listener = getActionListener();
				listener.getAction().setMessage("id09", "test"+p);
				listener.getListener().actionPerformed(action.getActionEvent());
				p++;

			}

		} else {
			button.addActionListener(new ActionListener() {

				@Override
				public void actionPerformed(final ActionEvent e) {
					int p = 0;
					final IActionListener<ActionListener, ActionEvent, Object> listener = getActionListener();
					listener.getAction().setMessage("id08", "begin");
					listener.getListener().actionPerformed(e);
					

				}
			});
		}
		
		panel.add(button);
		return panel;
	}

}


}}}


 