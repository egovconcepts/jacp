#labels Documentation,JACP,JacpFXJavaFX2,Spring
#sidebar JACPDocumentation



= JacpFX  documentation =

The JacpFX2 Project is an API to create *Rich Clients* in *MVC* style with *JavaFX 2*, *Spring* (or other DI frameworks) and an Actor like component approach. It provides a simple API to create a workspace, perspectives, components and to compose your Client application easily. All components triggered by *messages* and have a defined life cycle; their handle() methods is always executed in a *separate thread*, so the developer do not to have to manage own threading mechanism or be afraid of locking and unresponsive UI. The API uses dependency injection to initialize all parts of your client; the currently used DI implementation is Spring. It is possible to inject “normal” spring beans to your components and to use the complete Spring stack in your JACP Application.

<wiki:toc max_depth="3" />

= The Application Launcher =

The “Application Launcher” is the entry point where you define the spring xml and where the complete stack of Spring, JavaFX 2 and JACP  is started. The {{{postInit(Stage stage)}}} method gives you the ability to make custom changes on the JavaFX2 Stage instance. You have to define a {{{main}}} method on your own and start the JavaFX2 context by using the default {{{JavaFX2 Application}}} class.

*Example Application Lauchner*
{{{
public class WorkbenchMain extends AFX2SpringLauncher {
	public TestOneWorkbenchMain() {
		// define the spring xml
		super("main.xml");
	}

	@Override
	public void postInit(Stage stage) {
	}

	/**
	 * @param args
	 */
	public static void main(String[] args) {
	    // start the JavaFX2 context
		Application.launch(args);

	}

}
}}}

The structure of a JACP/Spring application looks like this:
<img src="http://jacp.googlecode.com/svn/wiki/JACP_Overview_v1.png"/>

Below you find an example xml of a simple JACP project:

{{{
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">


	<bean id="workbench" class="org.jacp.javafx2.rcp.workbench.Workbench">
		<property name="perspectives">
			<list>
				<ref bean="perspectiveOne" />
			</list>
		</property>
	</bean>

	<bean id="perspectiveOne" class="org.jacp.javafx2.rcp.perspectives.PerspectiveOne">
		<property name="name" value="perspectiveOne" />
		<property name="id" value="id01" />
		<property name="active" value="true" />
		<property name="subcomponents">
			<list>
				<ref bean="demoFX2ComponentOne" />
				<ref bean="demoFX2ComponentTwo" />
			</list>
		</property>
	</bean>

	<bean id="demoFX2ComponentOne" class="org.jacp.javafx2.rcp.components.DemoFX2ComponentOne">
		<property name="name" value="demoFX2ComponentOne" />
		<property name="active" value="true" />
		<property name="id" value="id001" />
		<property name="executionTarget" value="P0" />
	</bean>
	<bean id="demoFX2ComponentTwo" class="org.jacp.javafx2.rcp.components.DemoFX2ComponentTwo">
		<property name="name" value="demoFX2ComponentTwo" />
		<property name="active" value="false" />
		<property name="id" value="id002" />
		<property name="executionTarget" value="P1" />
	</bean>

</beans>
}}}
It is planned to move all meta-data configurations like {{{"id"}}}, {{{"name"}}},{{{"executionTarget"}}} and {{{"active"}}} to annotations in a later version. The references workbench->perspectives->components is likely to retain as xml configuration.

=Workbench=
The workbench is the root node of your client project, providing simple interfaces to configure the basic behavior of your client. Besides the application launcher, it is the only component where you can get access to the JavaFX2 “Stage” to define a custom window decorator and other things you like. Furthermore it groups all the defined perspectives in the spring - xml (one-to-many relation).  It consists of two methods you have to implement, the *{{{handleInitialLayout(IAction<Event, Object> action, IWorkbenchLayout<Node> layout,Stage stage)}}}* and *{{{postHandle(FX2ComponentLayout layout)}}}*. The {{{action}}}-object will always contain the default initialization message {{{“init”}}}, this message is default for all components on application start up. The Stage reference will give you the reference to the JavaFX Stage, here you can place some custom settings for your application. The  *{{{IWorkbenchLayout<Node> layout}}}* reference is your entry to configure following thinks on your application:
 * *{{{WorkbenchXYSize(x,y):}}}* defines the initial workbench size
 * *{{{MenuEnabled(boolean):}}}* enable main menu if needed, the entries are defined later; here you only declare if a menu is activated
 * *{{{Style(StageStyle):}}}* here you define the default {{{StageStyle}}} (decorated/undecorated)
 * *{{{registerToolBar(ToolbarPosition):}}}* enable tool bars in NORTH,SOUTH, EAST, WEST; those registered toolbars are accessible in all perspective and components, but you are free to define custom toolbars in your component which are not accessible for all others.

The *{{{postHandle(FX2ComponentLayout layout)}}}* method is executed when finishing “handleInitialLayout” and gives you access to the initialized menu and tool bars (if you defined them). 
 * {{{layout.getMenu()}}} will give you the reference to the main menu instance
 * {{{layout.getRegisteredToolBar(ToolbarPosition.NORTH)}}} returns the reference to the “north” toolbar if defined in “handleInitialLayout” before 

A workbench can handle many perspectives, but only one can be displayed simultaneously. The current active perspective is always the one where the last message appear (or a component of this perspective). All other running perspectives are hided in the background, so a perspective provides the typical layout of your application, not the workbench. You can consider the workbench as a container for perspectives (micro applications) who coordinates all children and gives you the ability to define some basic layout settings like declaring toolbars and a menu.

*Example workbench*:
{{{
public class Workbench extends AFX2Workbench {

	@Override
	public void handleInitialLayout(final IAction<Event, Object> action,
			final IWorkbenchLayout<Node> layout, final Stage stage) {
		layout.setWorkbenchXYSize(1024, 768);
		layout.registerToolBar(ToolbarPosition.NORTH);
		layout.registerToolBar(ToolbarPosition.SOUTH);
		layout.setStyle(StageStyle.DECORATED);
		layout.setMenuEnabled(true);
	}

	@Override
	public void postHandle(FX2ComponentLayout layout) {
		final ToolBar topBar = layout
				.getRegisteredToolBar(ToolbarPosition.NORTH);
		Button close = new Button("close");
		close.setOnMouseClicked(new EventHandler<Event>() {

			@Override
			public void handle(Event arg0) {
				System.exit(0);

			}
		});
		topBar.getItems().add(close);
	}

}
}}}


=Perspective=
A perspective is a (UI-) container like all other components (it’s children) and behave quite similar to components. It has a handle (handlePerspective) method and can be triggered by messages  from other perspectives and components. Different to components is, that a perspective will *always run on {{{FX Application thread}}}*, so this is NOT the place where you put some complex code or long running tasks. The *real task* of a perspective is to define the *layout* of your current view. The ability to trigger perspectives by messages gives you the freedom to change the layout at runtime and to adopt the view for your current needs.<br/> 
A typical UI application has a root node and a large tree of components which represents your UI structure. The leaf nodes of such a component tree are your user-nodes containing {{{Buttons}}}, {{{TextFields}}} and so on.
The root node in JACP is provided by the workbench; a perspective represents your (complex) UI tree and defines place-holders for your components (see picture 1). So, for a typical business application you can create a {{{SplitPane}}} in your perspective, which is the root node (or the root of this subtree), place a {{{GridPane}}} on the left and on the right and register those {{{GridPanes}}} as “Targets” for your components. 

<img src="http://jacp.googlecode.com/svn/wiki/JACP_NodeTree_View.png"/>

This means that you define the basic layout of your current view on perspective layer, but the {{{Buttons}}}, {{{TextFields}}} and so on are implemented in your components later. The *UI subtree* created here can be *as complex as you want* but you will always have to register the *root* and the *leaf (targets)* of this complex UI. The ability to register the root and the leafs is provided by the {{{IPerspectiveLayout}}} interface, the *{{{handlePerspective}}}* method gives you a reference to the perspective specific instance of this interface.
 * {{{layout.registerRootComponent(node):}}} register the root node of your perspective UI 
 * {{{layout.registerTargetLayoutComponent("top", nodeTop)}}} register a leaf component (a target where your components can register at)
 
 You can register as many targets as you want, they are just a place-holder were an UI subtree of your components can be linked in. Like all other components a perspective has a defined life cycle.

== The perspective life cycle ==
When a perspective is activated the {{{“onStartPerspective”}}} method is executed, followed by {{{“handlePerspective”}}} and when the perspective is disabled the {{{“onTearDownPerspective”}}} is executed. 
The purpose of {{{“onStartPerspective”}}} is, to add Menu and {{{ToolBar}}} entries to the Client, while in the {{{“onTearDownPerspective”}}} method you should remove all entries.  

<img src="http://jacp.googlecode.com/svn/wiki/JACP_Perspective_Lifecycle.png"/>

*Example perspective*
{{{
public class PerspectiveOne extends AFX2Perspective {

 	@Override
        public void onStartPerspective(FX2ComponentLayout layout) {

        }

        @Override
        public void onTearDownPerspective(FX2ComponentLayout layout) {


        }

        @Override
        public void handlePerspective(IAction<Event, Object> action,
                        FX2PerspectiveLayout perspectiveLayout) {
			// declare the root
			SplitPane root = new SplitPane();
		
			// declare the targets
			ScrollPane scrollPaneLeft = new ScrollPane();
			ScrollPane scrollPaneRight = new ScrollPane();
		
			root.getItems().addAll(scrollPaneLeft, scrollPaneRight);
			
			// register the root
			perspectiveLayout.registerRootComponent(root);
		
			// register the targets
			perspectiveLayout.registerTargetLayoutComponent("leftTarget", scrollPaneLeft);
			perspectiveLayout.registerTargetLayoutComponent("rightTarget", scrollPaneRight);

		} 

}

}}}

= Components = 
Components are the place where you put all the complex UI code, service calls and long running tasks in. All components have an input and an output. The input is always an {{{Action}}}-object and the output is either a view (in case you use an UI component) or any type of object. Currently you can use three types of components: {{{AFX2Components}}} are UI components, {{{ACallback- and AStatelessCallbackComponents}}} are non-UI components. All components in common is, that they have a {{{“handle”}}} method that is *not running on FX application thread*, so the execution of this block of code will not stop the execution of the rest of your UI. Also all component types can be activated and disabled.

== {{{AFX2Component}}} == 
This type of component is used to create UI parts like views or editors in other RCP frameworks. While you created your basic layout on perspective level, {{{AFX2Component}}} are used to fill your UI with functionality like {{{Forms}}}, {{{Tables}}} and so on. *{{{AFX2Components}}}* are *controller* classes and returning a *View-element* to the parent perspective. The created *View-element* will be integrated at a defined target of your perspective. 
The interface of AFX2Component defines following four methods you have to implement:
 * *{{{onStartComponent(FX2ComponentLayout layout):}}}* define {{{Menu-}}} , {{{ToolBar-entries}}} and custom Node elements on component {{{start-up}}}. If the current component has {{{Menu-}}} or {{{ToolBar-entries}}} define them here; the {{{FX2ComponentLayout}}} contains the reference to main {{{ToolBars}}} and {{{Menu}}}.
 * *{{{onTearDownComponent(FX2ComponentLayout layout):}}}* remove {{{Menu-}}} and {{{ToolBar-entries}}}; if you defined any entries remove them from main {{{ToolBar}}} and {{{Menu}}}. This method is for cleaning purposes.
 * *{{{Node handleAction(IAction<Event, Object> action):}}}* Handle any complex operations like DB access, service calls or create new UI components, unless you are modify existing UI elements, you are free to create any new UI-components. This method will be executed in a separate Thread *(Worker Thread)* and will not block the FX application thread from execution. The returned value is the View-element that will be passed to the *postHandle* method, if no changes are made in the *postHandle* method it will be displayed at defined target in associated perspective. You can use the handle method to initially create a large and complex UI tree, but you should avoid modifications of existing trees. You are also free to return a null value and to create the View-element in the postHanle method. On component start-up the action parameter contains the message "init" like all other components, later the "action" parameter contains the specific message to this component.  You can modify the state of your component by checking the content of your action message.
 * *{{{Node postHandleAction(Node node, IAction<Event, Object> action):}}}* Post handle the component action. This method is the place where you create and modify the UI View-element. The Node parameter is the object you created and passed in your *handle* method, if your passed a null value this parameter will also be null. The action parameter is always the same like passed to the handle method.

Some methods defined by the interface are used to modify the control flow of your component:
  * *{{{setActive(boolean active):}}}* active / disable the current component. You can modify the value in the {{{handle}}} and {{{postHandle}}} method
  * *{{{setExecutionTarget(String targetId):}}}* modify the {{{executionTarget}}} of your component. You can change the target at runtime, the notation is "perspectiveId.targetId".
  
*Example UI component*
{{{
public class DemoFX2ComponentOne extends AFX2Component {

	private GridPane grid;
	private Text category;
	private Button button;
	private MenuItem item;

	@Override
	public Node handleAction(IAction<Event, Object> action) {		
		if (action.getLastMessage().equals("init")) {
			this.grid = new GridPane();
			this.grid.setHgap(10);
			this.grid.setVgap(10);
			this.grid.setPadding(new Insets(0, 0, 0, 10));
			this.category = new Text("Hello:");
			this.category.setFont(Font.font("Tahoma", FontWeight.BOLD, 20));
			this.grid.add(category, 1, 0); 
			return this.grid;
		}
		return null;
	}	

	
	@Override
	public Node postHandleAction(Node node, IAction<Event, Object> action) {
		if (!action.getLastMessage().equals("init")) {
			this.category = new Text("World:");
			this.category.setFont(Font.font("Tahoma", FontWeight.BOLD, 20));
		}
		return this.grid;
	}

	@Override
	public void onStartComponent(final FX2ComponentLayout layout) {		
		ToolBar north = layout.getRegisteredToolBar(ToolbarPosition.SOUTH);
		MenuBar menu = layout.getMenu();
		// create button in tool bar
		button= new Button("Button 1");
		north.getItems().add(button);	

		ObservableList<Menu> menuList = menu.getMenus();
		Iterator<Menu> it = menuList.iterator();
		while(it.hasNext()) {
			Menu m = it.next();
			if(m.getText().equals("File")){
				// add menu item
				item = new MenuItem("Hello");
				m.getItems().add(item);
			}
		}		
	}

	@Override
	public void onTearDownComponent(final FX2ComponentLayout layout) {
		ToolBar north = layout.getRegisteredToolBar(ToolbarPosition.SOUTH);
		MenuBar menu = layout.getMenu();
		
		//remove button from tool bar
		north.getItems().remove(button);
		
		ObservableList<Menu> menuList = menu.getMenus();
		Iterator<Menu> it = menuList.iterator();
		while(it.hasNext()) {
			Menu m = it.next();
			if(m.getText().equals("File")){
				m.getItems().remove(item);
			}
		}		
	}
}
}}}
===* {{{AFX2Component}}} life cycle *===
<img src="http://jacp.googlecode.com/svn/wiki/JACP_UI-Component_Lifecycle.png"/>

== {{{ACallbackComponent}}} == 
An {{{ACallbackComponent}}} is a stateful non UI component. Like all JACP components it has a {{{handle}}} method that is executed in a separate Thread *( Worker Thread)*. This type of component is a controller component that can be used to handle long running tasks and service calls. The result of your task will be send to the message caller by default. This type of component has one method you have to implement:
 *  *{{{Object handleAction(IAction<Event, Object> action)}}}*: The input parameter "action" contains the specific message to this component. You can modify the state of your component by checking the content of your action message. The output (return value) of an {{{ACallbackComponent}}} is any kind of object that will be returned to the calling component (request/response semantic). You are free to redirect the return value to any component you want.

Some methods defined by the interface are used to modify the control flow of your component:
  * *{{{setActive(boolean active):}}}* active / disable the current component. You can modify the value in the {{{handle}}} and {{{postHandle}}} method
  * *{{{setExecutionTarget(String targetId):}}}* modify the {{{executionTarget}}} of your component. You can change the target at runtime, the notation is "perspectiveId". The {{{executionTarget}}} in this context means "the runtime perspective". You can move the component to any perspective you want. Moving a component to a specific perspective can speed up the message calls in one perspective context. Locale message calls are executed faster.  
  * *{{{setHandleTarget(String targetId):}}}*  modify the target of the return value; by default the return value is always send to the caller component but you can "redirect" it to any component you want.

*Example {{{ACallbackComponent}}}*
{{{
public class StatefulComponent extends ACallbackComponent{
	int c = 0;
	@Override
	public Object handleAction(IAction<Event, Object> action) {
		c = c++;
		if(action.getLastMessage().equals("ping")) return "pong";
		return "ping";
	}

}
}}}

===* {{{ACallbackComponent}}} life cycle *===

<img src="http://jacp.googlecode.com/svn/wiki/JACP_Stateful-Component.png"/>

== {{{AStatelessCallbackComponents}}} == 
An {{{AStatelessCallbackComponents}}} is a stateless non UI component.  Like all JACP components it has a {{{handle}}} method that is executed in a separate Thread *( Worker Thread)*. Similar to an {{{ACallbackComponent}}} it is a controller component, but in contrast it can have more than one running instance. The purpose of this component is to scale workload on different instances and threads. You can place some complex and long running tasks in the {{{AStatelessCallbackComponents}}} `handle` method and JACP creates as many instances and threads as needed (depending on your CPU count). For example you can place some code to read a file from your file system or to get some rows from your table. When many messages are send to an {{{AStatelessCallbackComponents}}} the scheduler creates a defined amount of instances and threads to work off all the messages in parallel. The result will be send to message caller exactly like an {{{ACallbackComponent}}} (request/response). 

*Example {{{AStatelessCallbackComponents}}}*

{{{
public class StatelessComponentOne extends AStatelessCallbackComponent{

	@Override
	public Object handleAction(IAction<Event, Object> action) {
		if(action.getLastMessage() instanceof File){
			File folder = (File) action.getLastMessage();
			if(folder.isDirectory()) {
				for(String file: folder.list()){
					System.out.println(file);
				}
			}
		}
		return " ";
	}

}
}}}

===* {{{AStatelessCallbackComponents}}} life cycle *===
<img src="http://jacp.googlecode.com/svn/wiki/JACP_Stateless-Component.png"/>

= JACP Messaging = 
The JACP Framework is all about messaging. While you are free to use the default {{{JavaFX2 EventHandler}}} concepts in your {{{View/UI}}}, you can use the JACP listeners to trigger messages to other JACP components. Messaging is the basic concept to change the state of an JACP component (and perspective too) and to exchange data between components. All messages to a JACP component are handled in a separate threads so you outsource complex computations from the *{{{FX application thread}}}* to a *worker thread*. The JACP listener concept fits well to the default {{{JavaFX 2 EventHandler}}} (a JACP listener implements an {{{JavaFX 2 EventHandler}}}) so you can add an JACP listener to any JavaFX2 Node to handle it's mouse-, keyboard- and other events. The JACP listener encapsulates the {{{JavaFX 2}}} event, the message and the target component-id in an {{{Action}}} object. This atomic {{{Action}}} will be send to the receiver and can be handled by message-content or event-type in the target-component handle method. Each JACP Component has it's own message queue (postbox) containing all messages to this component, the scheduler providing the messages to the component handle method.  
<img src="http://jacp.googlecode.com/svn/wiki/JACP_ComponentMessage_View.png"/>

The {{{getActionListener}}} interface defines two methods; {{{getActionListener(Object)}}} is used for *local messages* where the calling component is also the target component. The {{{getActionListener(string, object)}}} providing an interface to send *global messages*, the method takes a string as message target-id and an object representing a message. 

== *Add JACP local listener to {{{JavaFX2}}} Node* ==
{{{
IActionListener<EventHandler<Event>, Event, Object> listener = getActionListener("hello");
Button button = new Button("click me");
button.setOnMouseClicked((EventHandler<? super MouseEvent>) listener);
}}}

== *Add JACP listener to {{{JavaFX2}}} Node* ==
{{{
IActionListener<EventHandler<Event>, Event, Object> listener = getActionListener("id01.id001", "hello");
Button button = new Button("click me");
button.setOnMouseClicked((EventHandler<? super MouseEvent>) listener);
}}}

You can also trigger messages without involving a JavaFX2 Node by invoking the listeners {{{performAction(event)}}} method.

= JACP {{{OptionPane}}} =
