#labels Documentation,JACP,JacpFX,Spring,JavaFX
= JacpFX  documentation UNDER CONSTRUCTION (08. Oct. 2012) =

The JacpFX Project is an API to create *Rich Clients* in *MVC* style with *JavaFX*, *Spring* (or other DI frameworks) and an Actor like component approach. It provides a simple API to create a workspace, perspectives and components; to communicate with all parts trough messages and to compose your Client application easily. All components triggered by *messages* and have a defined life cycle; a component {{{handle()}}} method is always executed in a *separate thread*, so developers should have less effort on threading topics nor be afraid of locking and unresponsive UI. The API uses dependency injection to initialize all parts of your client; the currently used DI implementation is Spring. You can inject spring beans to your components and use the complete Spring stack in your JACP Application.

<wiki:toc max_depth="3" />

= The Application Launcher =

The “Application Launcher” is the entry point where you define the spring xml and where the complete stack of Spring, JavaFX and JacpFX  is started. The {{{postInit(Stage stage)}}} method gives you the ability to make custom changes on the JavaFX Stage instance. You have to define a {{{main}}} method on your own and start the JavaFX context by using the default {{{JavaFX Application}}} class.

*Example Application Lauchner*
{{{
public class ApplicationLauncher extends AFXSpringLauncher {
	public ApplicationLauncher() {
		// define the spring xml
		super("main.xml");
	}

	@Override
	public void postInit(Stage stage) {
               //add application icons
               stage.getIcons().add(new Image("images/icons/JACP_512_512.png"));
	       // add style sheet
	       scene.getStylesheets().addAll(
				ApplicationLauncher.class.getResource("/styles/style.css")
						.toExternalForm());
	}
 
	public static void main(String[] args) {
	    // start the JavaFX2 context
		Application.launch(args);

	}

}
}}}

The structure of a JacpFX application looks like this:
<img src="http://jacp.googlecode.com/svn/wiki/JACP_Overview_v1.png"/>

Below you find an example xml of a simple JacpFX project:

{{{
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">

	<bean id="workbench" class="org.jacp.javafx.rcp.workbench.Workbench">
		<property name="perspectives">
			<list>
				<ref bean="perspectiveOne" />
			</list>
		</property>
	</bean>

	<bean id="perspectiveOne" class="org.jacp.javafx.rcp.perspectives.PerspectiveOne">
		<property name="subcomponents">
			<list>
				<ref bean="demoFX2ComponentOne" />
				<ref bean="demoFX2ComponentTwo" />
			</list>
		</property>
	</bean>

	<bean id="demoFX2ComponentOne" class="org.jacp.javafx.rcp.components.DemoFX2ComponentOne"/>

	<bean id="demoFX2ComponentTwo" class="org.jacp.javafx.rcp.components.DemoFX2ComponentTwo"/>


</beans>
}}}

All meta-data configurations like *{{{"id"}}}, {{{"name"}}},{{{"executionTarget"}}}* and so on are defined by *annotations* directly in the component (see annotations overview).

=Workbench=
The workbench is the root node of your client project, providing simple interfaces to configure the basic behavior of your client. Besides the application launcher, it is the only component where you can get direct access to the JavaFX “Stage”. Furthermore a workbench logically groups all perspectives defined in the spring - xml (one-to-many relation).  He consists of two methods you have to implement, the *{{{handleInitialLayout(IAction<Event, Object> action, IWorkbenchLayout<Node> layout, Stage stage)}}}* and *{{{postHandle(FXComponentLayout layout)}}}*. The {{{action}}}-object in handleInitialLayout will always contain the default initialization message {{{“init”}}}, this message is default for all components on application start up. The Stage reference will give you the reference to the JavaFX Stage, here you can place some custom settings for your application. The  *{{{IWorkbenchLayout<Node> layout}}}* reference is your entry to configure following thinks on your application:
 * *{{{WorkbenchXYSize(x,y):}}}* defines the initial workbench size
 * *{{{MenuEnabled(boolean):}}}* enable the main menu if needed, the entries are defined later
 * *{{{Style(StageStyle):}}}* here you define the default {{{StageStyle}}} (decorated/undecorated), on OSX only decorated is available
 * *{{{registerToolBar(ToolbarPosition):}}}* enable tool bars in NORTH,SOUTH, EAST, WEST; those registered toolbars are accessible in all perspective and components, but you are free to define custom toolbars in your component which are not accessible for all others.

The *{{{postHandle(FXComponentLayout layout)}}}* method is executed when “handleInitialLayout” execution is finished and gives you access to the initialized menu and tool bars (if you defined them). 
 * *{{{JACPMenuBar menu = layout.getMenu()}}}* will give you the reference to the main menu instance
 * *{{{JACPToolBar toolbarNorth = layout.getRegisteredToolBar(ToolbarPosition.NORTH)}}}* returns the reference to the “north” toolbar if defined in “handleInitialLayout” before 

A workbench can handle many perspectives, but only one can be displayed at once (window mode is planned in later versions). The current active perspective is always the one where the last message appear (or a component of this perspective). All other running perspectives are hidden in background. A perspective provides the typical layout of your application, *not* the workbench. You can consider the workbench as a container for perspectives (micro applications) who coordinates all children and gives you the ability to define some basic settings like declaring toolbars and a menu and initial application size.

*Example workbench*:
{{{
public class Workbench extends AFXWorkbench {

	@Override
	public void handleInitialLayout(final IAction<Event, Object> action,
			final IWorkbenchLayout<Node> layout, final Stage stage) {
		layout.setWorkbenchXYSize(1024, 768);
		layout.registerToolBar(ToolbarPosition.NORTH);
		layout.setStyle(StageStyle.DECORATED);
		layout.setMenuEnabled(true);
	}

	@Override
	public void postHandle(FXComponentLayout layout) {
                final JACPMenuBar menu = layout.getMenu();
		final JACPToolBar topBar = layout
				.getRegisteredToolBar(ToolbarPosition.NORTH);
		Button close = new Button("close");
		topBar.getItems().add(close);
		final Menu menuFile = new Menu("File");
                menu.getMenus().addAll(menuFile);
	}

}
}}}


=Perspective=
A perspective is a (UI-) container like all other components (it’s children) and behave quite similar to components. It has a handle (handlePerspective) method and can be triggered by messages from other perspectives and components. Different to components is, that a perspective will *always run on {{{FX Application thread}}}*, so this is NOT the place where you put some complex code or long running tasks. The *real task* of a perspective is to define the *layout* of your current view. The ability to trigger perspectives by messages gives you the freedom to change the layout at runtime and to adopt the view for your current needs.<br/> 
A typical UI application has a root node and a large tree of components which represents your UI structure. The leaf nodes of such a component tree are your user-nodes containing {{{Buttons}}}, {{{TextFields}}} and so on.
The root node in JacpFX is provided by the workbench; a perspective represents your (complex) UI tree and defines place-holders for your components (see picture 1). So, for a typical business application you can create a {{{SplitPane}}} in your perspective, which is the root node (or the root of this subtree), place a {{{GridPane}}} on the left and on the right and register those {{{GridPanes}}} as “Targets” for your components. 

<img src="http://jacp.googlecode.com/svn/wiki/JACP_NodeTree_View.png"/>

This means, that you define the basic layout of your current view on perspective layer, but the {{{Buttons}}}, {{{TextFields}}} and so on are implemented in your components later. The *UI subtree* created here can be *as complex as you want* but you will always have to register the *root* and the *leaf (targets)* of this complex UI. The ability to register the root and the leafs is provided by the {{{IPerspectiveLayout}}} interface, the *{{{handlePerspective}}}* method gives you a reference to the perspective specific instance of this interface.
 * {{{layout.registerRootComponent(node):}}} register the root node of your perspective UI 
 * {{{layout.registerTargetLayoutComponent("top", nodeTop)}}} register a leaf component (a target where your components can register at)
 
 You can register as many targets as you want, they are just a place-holder were an UI subtree of your components can be linked in. Like all other components a perspective has a defined life cycle. JacpFX 1.1 introduces FXML capabilities, so you can use FXML to define the perspective UI. The process of target registration did not changed and will be shown in an example below.

== The perspective life cycle ==
When a perspective is activated the method annotated with {{{“@OnStart”}}} is executed, followed by {{{“handlePerspective”}}} and when the perspective is disabled the method annotated with {{{“@OnTearDown”}}} is executed. 
The purpose of {{{“@OnStart”}}} annotation is, to allow initialization code and to add Menu and {{{ToolBar}}} entries to the Client, while in the {{{“@OnTearDown”}}} method you can do clean up work.  

<img src="http://jacp.googlecode.com/svn/wiki/JACP_Perspective_Lifecycle.png"/>

== Perspective types ==
Since JacpFX 1.1 you can define declarative (with FXML) and programmatic (plain Java/JavaFX) Perspectives. For both types you create a Perspective class (*{{{AFXPerspective}}}*) and declare the targets inside. The type of a Perspective is controlled by annotations.

=== Programmatic Perspectives ===
This type is defined by the {{{@Perspective}}} annotation with following attributes:
 * *id*, the Perspective id
 * *name*, the Perspective name
 * *resourceBundleLocation*, the bundle location for localization (optional)
 * *localeID*, the default locale (optional)


*Example Perspective*
{{{
@Perspective(id = "id001", name = "perspectiveOne", resourceBundleLocation = "bundles.languageBundle", localeID = "en_US")
public class PerspectiveOne extends AFXPerspective {
 
        @Override
        public void handlePerspective(IAction<Event, Object> action,
                        PerspectiveLayout perspectiveLayout) {
			// declare the root
			SplitPane root = new SplitPane();
		
			// declare the targets
			ScrollPane scrollPaneLeft = new ScrollPane();
			ScrollPane scrollPaneRight = new ScrollPane();
		
			root.getItems().addAll(scrollPaneLeft, scrollPaneRight);
			
			// register the root
			perspectiveLayout.registerRootComponent(root);
		
			// register the targets
			perspectiveLayout.registerTargetLayoutComponent("leftTarget", scrollPaneLeft);
			perspectiveLayout.registerTargetLayoutComponent("rightTarget", scrollPaneRight);

		} 

        @OnStart
	public void onStartPerspective(final FXComponentLayout layout,
			final ResourceBundle resourceBundle) {
		// define toolbars and menu entries
	}

	@OnTearDown
	public void onTearDownPerspective(final FXComponentLayout arg0) {
		// remove toolbars and menu entries when close perspective

	}

}

}}}

=== Declerative Perspectives ===
This type is also defined by the {{{@Perspective}}} annotation and extends the default perspective annotation attributes with:
 * *viewLocation*, the URI to the FXML file



*Example (Declarative) Perspective*
{{{
@Perspective(id = "id02", name = "perspectiveOne", viewLocation = "/fxml/perspectiveOne.fxml", resourceBundleLocation = "bundles.languageBundle", localeID = "en_US")
public class PerspectiveOne extends AFXPerspective { 
        @FXML
	private GridPane gridPaneLeft;
	@FXML
	private GridPane gridPaneRight;

	@Override
	public void handlePerspective(final IAction<Event, Object> action,
			final PerspectiveLayout perspectiveLayout) {
		if (action.getLastMessage().equals(MessageUtil.INIT)) {
			// register left panel
			perspectiveLayout.registerTargetLayoutComponent("Pleft",
					this.gridPaneLeft);
			// register main panel
			perspectiveLayout.registerTargetLayoutComponent("PMain",
					this.gridPaneRight);
		}

	}

	@OnStart
	public void onStartPerspective(final FXComponentLayout layout,
			final ResourceBundle resourceBundle) {
		// define toolbars and menu entries
	}

	@OnTearDown
	public void onTearDownPerspective(final FXComponentLayout arg0) {
		// remove toolbars and menu entries when close perspective

	}

}

}}}

* Example FXML *
{{{
<?xml version="1.0" encoding="UTF-8"?>

<?import java.lang.*?>
<?import java.util.*?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>
<?import javafx.scene.paint.*?>

<BorderPane id="BorderPane" xmlns:fx="http://javafx.com/fxml" fx:controller="org.jacp.javafx.rcp.perspective.AFXPerspective">
  <center>
    <SplitPane id="splitPaneHorizontal1" cache="true" dividerPositions="0.20" minHeight="100.0" minWidth="200.0" styleClass="hsplitpane">
      <items>
        <GridPane fx:id="gridPaneLeft">
          <columnConstraints>
            <ColumnConstraints hgrow="SOMETIMES" minWidth="10.0" prefWidth="100.0" />
          </columnConstraints>
          <rowConstraints>
            <RowConstraints minHeight="10.0" prefHeight="30.0" vgrow="SOMETIMES" />
          </rowConstraints>
        </GridPane>
          <GridPane fx:id="gridPaneRight">
	      <columnConstraints>
	          <ColumnConstraints hgrow="SOMETIMES" minWidth="10.0" prefWidth="100.0" />
	      </columnConstraints>
	      <rowConstraints>
	        <RowConstraints minHeight="10.0" prefHeight="30.0" vgrow="SOMETIMES" />
	      </rowConstraints>
	  </GridPane>
      </items>
    </SplitPane>
  </center>
</BorderPane>

}}}

=== the fx:controller declaration ===
Since the fx:controller attribute is mandatory in combination with JavaFX controllers you simply define the abstract perspective class (org.jacp.javafx.rcp.perspective.AFXPerspective) or the concrete perspective where this FXML is associated. Generally you should prefer the abstract declaration, so you can reuse the FXML in other perspectives. 


= Components = 
Components are basically distinguished in UI- and NonUI-Components; UIComponents are the place where you put all the complex UI code ({{{TextFields}}}, {{{Buttons}}}, etc.) in. NonUIComponents are services for long running tasks. All components have an input and an output. The input is always an {{{Action}}} and the output is either a view (in case you use an UIcomponent) or any type of object (in case of services). Currently you can use four types of components: {{{AFXComponent}}} are UI components, they can either be plain {{{JavaFX}}} components or FXML components (depends on annotation ). {{{AStatefulCallbackComponent and AStatelessCallbackComponent}}} are NonUIcomponents. All components in common is, that they have a {{{“handle”}}} method that is *running outside the FX application thread*, so the execution of this method will not block the rest of your UI. 

== {{{AFXComponent}}} == 
This type of component is used to create UI parts in {{{JavaFX}}} or FXML (similar to views or editors in other RCP frameworks). While you created your basic layout on perspective level, {{{AFXComponent}}}´s are used to fill your UI with elements and components like {{{Forms}}}, {{{Tables}}} and so on. *{{{AFXComponent}}}´s* are *controller* classes. While {{{JavaFX}}} components returning a *View-element* (Node) to the parent perspective, the XML-document of a FXML component is representing the view. The created *View-element* ({{{JavaFX}}} or FXML) will be integrated at a defined target of your perspective. 
The interface of AFXComponent defines following two methods to implement:
 * *{{{Node handleAction(IAction<Event, Object> action):}}}* Handle any complex operations like DB access, service calls or create new UI components. Unless you are not modify existing UI elements, you are free to create any new UI-components. This method will be executed in a separate Thread *(Worker Thread)* and will not block the FX application thread from execution. You can use the handle method to create initially a large and complex UI tree, but you should avoid modifications of existing trees (it will throw an {{{UnsupportedOperationException}}} exception). You are also free to return a null value and to create the View-element in the postHanle method. On component start-up the action contains an "init" message like all other components, later the "action" parameter contains the specific message to this component.
 * *{{{Node postHandleAction(Node node, IAction<Event, Object> action):}}}* This method is the place where you create and *modify* the UI View-element. The Node parameter is the object you created and passed in your *handle* method before. In case of {{{JavaFX}}} components the return value (a Node element) will be submitted to the defined target in perspective. In case of FXML components you should not return any Node (in will throw an {{{UnsupportedOperationException}}}), here the associated FXML document is the Node that is passed to the target in corresponding perspective.

Some methods defined by the interface are used to modify the control flow of your component:
  * *{{{setActive(boolean active):}}}* active / disable the current component. You can modify the value in the {{{handle}}} and {{{postHandle}}} method
  * *{{{setExecutionTarget(String targetId):}}}* modify the {{{executionTarget}}} of your component. You can change the target at runtime, the notation is "perspectiveId.targetId".

*Method level annotations* 
 * *{{{@OnStart:}}}* methods annotated with {{{OnStart}}} will be executed on activation. This can either be on application startup or when the component is re-/activated. The method signature can have no parameters, the {{{FXComponentLayout layout}}} parameter and/or the reference to the {{{ResourceBundle resourceBundle}}}. With the {{{FXComponentLayout layout}}} reference you can define {{{Menu-}}} and {{{ToolBar-entries}}} in your component. 
 * *{{{@OnTearDown:}}}* methods annotated with {{{OnTearDown}}} will be executed on application shutdown or when the component is deactivated. It has the same method signature like {{{OnStart}}}.
 
*Example JavaFX UI component*
{{{
@Component(defaultExecutionTarget = "Pleft", id = "id001", name = "componentOne", active = true, resourceBundleLocation = "bundles.languageBundle", localeID = "en_US")
public class DemoFXComponentOne extends AFXComponent {

	private GridPane grid;
	private Text category;
	private Button button;
	private MenuItem item;

	@Override
	public Node handleAction(IAction<Event, Object> action) {		
		if (action.getLastMessage().equals(MessageUtil.INIT)) {
		    // create UI Nodes on component start
			this.grid = new GridPane();
			this.grid.setHgap(10);
			this.grid.setVgap(10);
			this.grid.setPadding(new Insets(0, 0, 0, 10));
			this.category = new Text("Hello:");
			this.category.setFont(Font.font("Tahoma", FontWeight.BOLD, 20));
			this.grid.add(category, 1, 0); 
			return this.grid;
		}
		return null;
	}	

	
	@Override
	public Node postHandleAction(Node node, IAction<Event, Object> action) {
		if (!action.getLastMessage().equals(MessageUtil.INIT)) {
			// update UI tree on message
			this.category = new Text("World:");
			this.category.setFont(Font.font("Tahoma", FontWeight.BOLD, 20));
		}
		return this.grid;
	}
	
	@OnStart
	public void onStart(final FXComponentLayout layout,
			final ResourceBundle resourceBundle) {	
		JACPToolBar north = layout.getRegisteredToolBar(ToolbarPosition.SOUTH);
		JACPMenuBar menu = layout.getMenu();
		// create button in tool bar
		button= new Button("Button 1");
		north.getItems().add(button);	

		/// add menu entries
	}
	
	@OnTearDown
	public void onTearDownComponent(final FXComponentLayout layout) {
		JACPToolBar north = layout.getRegisteredToolBar(ToolbarPosition.SOUTH);
		JACPMenuBar menu = layout.getMenu();
		
		//remove button from tool bar
		north.getItems().remove(button);
		
		/// remove menu entries
	}
}
}}}

*Example FXML component*


===* {{{AFXComponent}}} life cycle *===
<img src="http://jacp.googlecode.com/svn/wiki/JACP_UI-Component_Lifecycle.png"/>

== {{{ACallbackComponent}}} == 
An {{{ACallbackComponent}}} is a stateful non UI component. Like all JacpFX components it has a {{{handle}}} method that is executed in a separate Thread *( Worker Thread)*. This type of component is a controller component that can be used to handle long running tasks and service calls. The result of your task will be send to the message caller by default. This type of component has one method you have to implement:
 *  *{{{Object handleAction(IAction<Event, Object> action)}}}*: The input parameter "action" contains the specific message to this component. You can modify the state of your component by checking the content of your action message. The output (return value) of an {{{ACallbackComponent}}} is any kind of object that will be returned to the calling component (request/response semantic). You are free to redirect the return value to any component you want.

Some methods defined by the interface are used to modify the control flow of your component:
  * *{{{setActive(boolean active):}}}* active / disable the current component. You can modify the value in the {{{handle}}} and {{{postHandle}}} method
  * *{{{setExecutionTarget(String targetId):}}}* modify the {{{executionTarget}}} of your component. You can change the target at runtime, the notation is "perspectiveId". The {{{executionTarget}}} in this context means "the runtime perspective". You can move the component to any perspective you want. Moving a component to a specific perspective can speed up the message calls in one perspective context. Locale message calls are executed faster.  
  * *{{{setHandleTarget(String targetId):}}}*  modify the target of the return value; by default the return value is always send to the caller component but you can "redirect" it to any component you want.

*Example {{{ACallbackComponent}}}*
{{{
public class StatefulComponent extends ACallbackComponent{
	int c = 0;
	@Override
	public Object handleAction(IAction<Event, Object> action) {
		c = c++;
		if(action.getLastMessage().equals("ping")) return "pong";
		return "ping";
	}

}
}}}

===* {{{ACallbackComponent}}} life cycle *===

<img src="http://jacp.googlecode.com/svn/wiki/JACP_Stateful-Component.png"/>

== {{{AStatelessCallbackComponents}}} == 
An {{{AStatelessCallbackComponents}}} is a stateless non UI component.  Like all JacpFX components it has a {{{handle}}} method that is executed in a separate Thread *( Worker Thread)*. Similar to an {{{ACallbackComponent}}} it is a controller component, but in contrast it can have more than one running instance. The purpose of this component is to scale workload on different instances and threads. You can place some complex and long running tasks in the {{{AStatelessCallbackComponents}}} `handle` method and JacpFX creates as many instances and threads as needed (depending on your CPU count). For example you can place some code to read a file from your file system or to get some rows from your table. When many messages are send to an {{{AStatelessCallbackComponents}}} the scheduler creates a defined amount of instances and threads to work off all the messages in parallel. The result will be send to message caller exactly like an {{{ACallbackComponent}}} (request/response). 

*Example {{{AStatelessCallbackComponents}}}*

{{{
public class StatelessComponentOne extends AStatelessCallbackComponent{

	@Override
	public Object handleAction(IAction<Event, Object> action) {
		if(action.getLastMessage() instanceof File){
			File folder = (File) action.getLastMessage();
			if(folder.isDirectory()) {
				for(String file: folder.list()){
					System.out.println(file);
				}
			}
		}
		return " ";
	}

}
}}}

===* {{{AStatelessCallbackComponents}}} life cycle *===
<img src="http://jacp.googlecode.com/svn/wiki/JACP_Stateless-Component.png"/>

= JacpFX Messaging = 
The JacpFX Framework is all about messaging. While you are free to use the default {{{JavaFX2 EventHandler}}} concepts in your {{{View/UI}}}, you can use the JacpFX listeners to trigger messages to other JacpFX components. Messaging is the basic concept to change the state of an JacpFX component (and perspective too) and to exchange data between components. All messages to a JacpFX component are handled in a separate threads so you outsource complex computations from the *{{{FX application thread}}}* to a *worker thread*. The JacpFX listener concept fits well to the default {{{JavaFX 2 EventHandler}}} (a JacpFX listener implements an {{{JavaFX 2 EventHandler}}}) so you can add an JacpFX listener to any JavaFX2 Node to handle it's mouse-, keyboard- and other events. The JacpFX listener encapsulates the {{{JavaFX 2}}} event, the message and the target component-id in an {{{Action}}} object. This atomic {{{Action}}} will be send to the receiver and can be handled by message-content or event-type in the target-component handle method. Each JacpFX Component has it's own message queue (postbox) containing all messages to this component, the scheduler providing the messages to the component handle method.  
<img src="http://jacp.googlecode.com/svn/wiki/JACP_ComponentMessage_View.png"/>

The {{{getActionListener}}} interface defines two methods; {{{getActionListener(Object)}}} is used for *local messages* where the calling component is also the target component. The {{{getActionListener(string, object)}}} providing an interface to send *global messages*, the method takes a string as message target-id and an object representing a message. 

== *Add JacpFX local listener to {{{JavaFX2}}} Node* ==
{{{
IActionListener<EventHandler<Event>, Event, Object> listener = getActionListener("hello");
Button button = new Button("click me");
button.setOnMouseClicked((EventHandler<? super MouseEvent>) listener);
}}}

== *Add JacpFX listener to {{{JavaFX2}}} Node* ==
{{{
IActionListener<EventHandler<Event>, Event, Object> listener = getActionListener("id01.id001", "hello");
Button button = new Button("click me");
button.setOnMouseClicked((EventHandler<? super MouseEvent>) listener);
}}}

You can trigger messages without involving a JavaFX2 Event by invoking the listeners {{{listener.performAction(event)}}} method. The address scheme is pretty simple, it is based on the Java package naming convention. Components are always located in a perspective so "id01" in the current example is the id of a perspective and "id001" the id of the target component. So by typing "id01.id001" you address the component "id001" in perspective "id01". You can also use simple naming like "id001" (without dots), this would mean that the target is either a perspective or a component inside the current perspective. The framework will try to resolve the correct target for you.

= Modal Messages =

== JacpFX {{{OptionPane}}} ==

The JacpFX Framework provides a default optionpane. 
The JACPOptionPane holds a title, a message and four types of buttons - OK, Cancel, Yes and No. 

You can use the JACPDialogUtil to create a JACPOptionPane.
To show up the optionpane, simply call showDialog(). 

The dialog will hide after an action was called. 

{{{
JACPOptionPane pane = JACPDialogUtil.createOptionPane("JACP OptionPane", "This is the default JACP OptionPane!");
pane.setOnOkAction(new EventHandler<ActionEvent>() {
	public void handle(ActionEvent arg0) {
		// OK action
		}
	});
pane.setOnCancelAction(new EventHandler<ActionEvent>() {
	public void handle(ActionEvent arg0) {
		// Cancel action
		}
	});
pane.setDefaultButton(JACPDialogButton.CANCEL);´
pane.setDefaultCloseButtonVisible(true);
pane.setDefaultCloseButtonOrientation(Pos.CENTER_RIGHT);
pane.showDialog();
	}}}	

<img src="http://jacp.googlecode.com/svn/wiki/JACP_Std_OptionPane.PNG"/>

== JacpFX Custom {{{Dialog}}} ==

You can use the JACPModalDialog to show and hide your custom dialogs. 

{{{
JACPModalDialog.getInstance().showModalMessage(new CustomOptionPane());
}}}


{{{
JACPModalDialog.getInstance().hideModalMessage();
}}}





<img src="http://jacp.googlecode.com/svn/wiki/JACP_Custom_OptionPane.PNG"/>

= JACPToolBar and JACPMenuBar =

= Annotations overview =

= localisation and internationalization =