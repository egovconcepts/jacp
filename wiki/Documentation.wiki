#labels Documentation,JavaFX2,Jacp
#JACP JavaFX 2 Documentation page

= JACP JavaFX 2 documentation =

The JACP JavaFX Project is an API to create Rich Clients in MVC style with JavaFX 2. It provides a simple API to create a workspace, perspectives, components and to compose your Client application easily. All components behave like controllers and triggered by messages similar to Spring MVC controllers. Components have a defined life cycle, their handle() methods is always executed in a separate thread, so the developer do not to have to manage own threading mechanism or be afraid of locking and unresponsive UI. The API uses dependency injection to initialize all parts of your client; the currently used DI implementation is Spring. It is possible to inject “normal” spring beans to your components and to use the complete Spring stack in your JACP Application.


= The Application Launcher =

The “Application Launcher” is the entry point where you define the spring xml and where the complete stack of Spring, JavaFX 2 and JACP  is started. It defines a main method so you have to declare your xml in the launchers constructor and can start the project.  The structure of a JACP/Spring application looks like this:
<img src="http://jacp.googlecode.com/svn/wiki/JACP_Overview_v1.png"/>

Below you find an example xml of a simple JACP project:

{{{
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">


	<bean id="workbench" class="org.jacp.javafx2.rcp.workbench.Workbench">
		<property name="perspectives">
			<list>
				<ref bean="perspectiveOne" />
			</list>
		</property>
	</bean>

	<bean id="perspectiveOne" class="org.jacp.javafx2.rcp.perspectives.PerspectiveOne">
		<property name="name" value="perspectiveOne" />
		<property name="id" value="id01" />
		<property name="active" value="true" />
		<property name="subcomponents">
			<list>
				<ref bean="demoFX2ComponentOne" />
				<ref bean="demoFX2ComponentTwo" />
			</list>
		</property>
	</bean>

	<bean id="demoFX2ComponentOne" class="org.jacp.javafx2.rcp.components.DemoFX2ComponentOne">
		<property name="name" value="demoFX2ComponentOne" />
		<property name="active" value="true" />
		<property name="id" value="id001" />
		<property name="executionTarget" value="P0" />
	</bean>
	<bean id="demoFX2ComponentTwo" class="org.jacp.javafx2.rcp.components.DemoFX2ComponentTwo">
		<property name="name" value="demoFX2ComponentTwo" />
		<property name="active" value="false" />
		<property name="id" value="id002" />
		<property name="executionTarget" value="P1" />
	</bean>

</beans>
}}}

=The Workbench=
The workbench is the root node of your client project, providing simple interfaces to configure the basic behaviour of your client. It consists of two methods you have to implement, the *{{{handleInitialLayout(IAction<Event, Object> action, IWorkbenchLayout<Node> layout,Stage stage)}}}* and *{{{postHandle(FX2ComponentLayout layout)}}}*. The action will always contain the default initialization message “init”, this message is default for all components on application start up. The Stage reference will give you the reference to the JavaFX Stage, here you can place some custom settings for your application. The  *{{{IWorkbenchLayout<Node> layout}}}* reference is your entry to configure following thinks on your application:
 * *{{{WorkbenchXYSize(x,y):}}}* defines the initial workbench size
 * *{{{MenuEnabled(boolean):}}}* enable main menu if needed, the entries are defined later; here you only declare if a menu is activated
 * *{{{Style(StageStyle):}}}* here you define the default {{{StageStyle}}} (decorated/undecorated)
 * *{{{registerToolBar(ToolbarPosition):}}}* enable tool bars in NORTH,SOUTH, EAST, WEST; those registered toolbars are accessible in all perspective and components, but you are free to define custom toolbars in your component which are not accessible for all others.

The *{{{postHandle(FX2ComponentLayout layout)}}}* method is executed when finishing “handleInitialLayout” and gives you access to the initialized menu and tool bars (if you defined them). 
 * {{{layout.getMenu()}}} will give you the reference to the main menu instance
 * {{{layout.getRegisteredToolBar(ToolbarPosition.NORTH)}}} returns the reference to the “north” toolbar if defined in “handleInitialLayout” before 

A workbench can handle many perspectives, but only one can be displayed simultaneously. The current perspective is always the one where the last message appear (or a component of this perspective). All other running perspectives are hided in the background, so a perspective provides the typical layout of your application, not the workbench. You can consider the workbench as a container for perspectives (micro applications) who coordinates all children and gives you the ability to define some basic layout settings like declaring toolbars and a menu.

*Example workbench*:
{{{
public class Workbench extends AFX2Workbench {

	@Override
	public void handleInitialLayout(final IAction<Event, Object> action,
			final IWorkbenchLayout<Node> layout, final Stage stage) {
		layout.setWorkbenchXYSize(1024, 768);
		layout.registerToolBar(ToolbarPosition.NORTH);
		layout.registerToolBar(ToolbarPosition.SOUTH);
		layout.setStyle(StageStyle.DECORATED);
		layout.setMenuEnabled(true);
	}

	@Override
	public void postHandle(FX2ComponentLayout layout) {
		final ToolBar topBar = layout
				.getRegisteredToolBar(ToolbarPosition.NORTH);
		Button close = new Button("close");
		close.setOnMouseClicked(new EventHandler<Event>() {

			@Override
			public void handle(Event arg0) {
				System.exit(0);

			}
		});
		topBar.getItems().add(close);
	}

}
}}}


=The Perspective=
A perspective is a container like all other components (it’s children) and behave quite similar to components. It has a handle (handlePerspective) method and can be triggered by messages  from other perspectives and components. Different to components is, that a perspective will *always run on {{{FX Application thread}}}*, so this is NOT the place where you put some complex code or long running tasks. The real task of a perspective is to define the layout of your current view. The ability to trigger perspectives by messages gives you the freedom to change the layout at runtime and to adopt the view for your current needs. 
A typical UI application has a root node and a large tree of components which represents your UI structure. The leave nodes of such a component tree are your user-nodes containing buttons, {{{TextFields}}} and so on.
The root node in JACP is provided by the workbench, a perspective represents your (complex) UI tree and defines placeholders for your components (see picture 1). So, for a typical business application you can create a {{{SplitPane}}} in your perspective, which is the root node (or the root of this subtree), place a {{{ScrollPane}}} on the left and on the right and register those {{{ScrollPanes}}} as “Targets” for your components. 

<img src="http://jacp.googlecode.com/svn/wiki/JACP_NodeTree_View.png"/>

This means you define the basic layout of your view in the perspective but the Buttons, {{{TextFields}}} and so on are implemented in your components later. The UI subtree created here can be as complex as you want but you will always have to register the root and the leave (targets) of this complex UI. The ability to register the root and the leaves is provided by the {{{IPerspectiveLayout}}} interface, the *{{{handlePerspective}}}* mehtod gives you a reference to the perspective specific instance of this interface.
 * {{{layout.registerRootComponent(node):}}} register the root node of your perspective UI 
 * {{{layout.registerTargetLayoutComponent("top", nodeTop)}}} register a leave component (a target where your components can register at)
 
 You can register as many targets as you want, they are just a placeholder were an UI subtree of your components can be linked in. Like all other components a perspective has a defined life cycle.

== The perspective lifecycle ==
When a perspective is activated the {{{“onStartPerspective”}}} method is executed, followed by {{{“handlePerspective”}}} and when the perspective is de-activated the {{{“onTearDownPerspective”}}} is executed. 
The purpose of {{{“onStartPerspective”}}} is, to add Menu and {{{ToolBar}}} entries to the Client, while in the {{{“onTearDownPerspective”}}} method you should remove all entries.  

<img src="http://jacp.googlecode.com/svn/wiki/JACP_Perspective_Lifecycle.png"/>

= The Components = 
Components are the place where you put all the complex UI code, service calls and long running tasks in. All components have an input and a output. The input is always an {{{Action}}} and the output is either a view (in case you use an UI component) or any type of object. Currently you can use three types of components: {{{AFX2Components}}} are UI components, {{{ACallback- and AStatelessCallbackComponents}}} are non-UI components. All components in common is, that they have a {{{“handle”}}} method that is not running on main application thread, so the execution of this block of code will not stop the execution of the rest of your UI. 

